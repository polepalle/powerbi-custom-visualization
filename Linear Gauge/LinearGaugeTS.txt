module powerbi.visuals {
    //Model
    
    export interface LinearGaugeBySQLBIData {
        titleLabel: string;
        subTitleLabel: string;
        showLabel: boolean;
        colorActual: string;
        colorComparison: string;
        states: number[];
        value: number;
        target: number;
        comparison: number;
        actual:number;
        percentage:number;
        min: number;
        max: number;
        trendValue1:number;
        trendValue2:number;
        actualFormat:string;
        targetFormat:string;
        trend1Format:string;
        trend2Format:string;
        minFormat:string;
        maxFormat:string;
        selector: data.Selector;      
        toolTipInfo: TooltipDataItem[];
        golbalValueMin:number;
    }
    
    //object variable which we used in customized color and text through UI options
  export var linearGaugeProps = {
        general: {
            ActualFillColor: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'ActualFillColor' },
            ComparisonFillColor: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'ComparisonFillColor' },
        },
          labels: {
                color: { objectName: 'labels', propertyName: 'color' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
            }
        
    };
    
 var globalminValue=0,globalminLength=0,globalTargetValue=0,globalTargetWidth=0;
    //Visual
    export class LinearGauge implements IVisual {
        //Variables 
        private svg: D3.Selection;
        private svgLinear: D3.Selection;
		private svgLinearNext: D3.Selection;
        private svgTitle: D3.Selection;
        private svgSubtitle: D3.Selection;
        private actual:D3.Selection;
        private percentage:D3.Selection;
        private dataView: DataView;
        private data: LinearGaugeBySQLBIData;
        private min:D3.Selection;
        private max:D3.Selection;
		private targetText:D3.Selection;
        private trendValue1:D3.Selection;
        private trendValue2:D3.Selection;
		private heading:D3.Selection;
		private subHeading:D3.Selection;
        private cardFormatSetting: CardFormatSetting;
        private metaDataColumn: DataViewMetadataColumn;
        public static getDefaultData(): LinearGaugeBySQLBIData {
            return {
                colorActual: 'orange',
                colorComparison: 'lightgrey',
                titleLabel: '',
                subTitleLabel: '',
                showLabel: true,
                states: [],
                min: 0,
                max: 1,
                value: 0,
                target: 0,
                comparison: 0,
                actual:0,
                percentage:0,
                trendValue1:0,
                trendValue2:0,
                actualFormat:'',
                targetFormat:'',
                minFormat:'',
                maxFormat:'',
                trend1Format:'',
                trend2Format:'',
                toolTipInfo: [],                              
                golbalValueMin:10,
				targetText:'',
                selector: SelectionId.createNull().getSelector()
            };
        }
   
    public getDefaultLabelSettings(show, labelColor, labelPrecision, format) {
         var defaultCountLabelPrecision = 0;
         var defaultDecimalLabelPrecision = 2;
         var defaultLabelColor = "#777777";  
           var precision=0;
                if (show === void 0) { show = false; }
                if (format) {
                    var hasDots = powerbi.NumberFormat.getCustomFormatMetadata(format).hasDots;
                }
                 precision = defaultCountLabelPrecision;
                if (labelPrecision) {
                    precision = labelPrecision;
                }
                else if (hasDots) {
                    precision = defaultDecimalLabelPrecision;
                }
                return {
                    show: show,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: precision,
                    labelColor: labelColor || defaultLabelColor,
                    formatterOptions: null,
                };
            }
            
              public getMetaDataColumn(dataView: DataView) {
            if (dataView && dataView.metadata && dataView.metadata.columns) {
                for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                    var column = dataView.metadata.columns[i];
                    if (column.isMeasure) {
                        this.metaDataColumn = column;
                        break;
                    }
                }
            }
        }
              public getDefaultFormatSettings(): CardFormatSetting {
            return {
                showTitle: true,
                textSize:null,
                labelSettings: this.getDefaultLabelSettings(true,'black', 0, undefined),
                wordWrap: false,
            };
        }
        //Capabilities what this visualization can do
        public static capabilities: VisualCapabilities = {
            dataRoles: [
                {
                    name: 'Y',// This will be the name of role and we can find element in an object with the role
                    kind: VisualDataRoleKind.Measure,//Type of value
                    displayName: 'Value',// it will display as measure header name
                },				
				 {
                    name: 'TargetValue',
                    kind: VisualDataRoleKind.Measure,
                    displayName: 'Target Value',
                }, {
                    name: 'MinValue',
                    kind: VisualDataRoleKind.Measure,
                    displayName: data.createDisplayNameGetter('Role_DisplayName_MinValue'),
                }, {
                    name: 'MaxValue',
                    kind: VisualDataRoleKind.Measure,
                    displayName: data.createDisplayNameGetter('Role_DisplayName_MaxValue'),
                 }, {
                    name: 'QualitativeState1Value',
                    kind: VisualDataRoleKind.Measure,
                    displayName: 'Trend Value 1',
                }, {
                    name: 'QualitativeState2Value',
                    kind: VisualDataRoleKind.Measure,
                    displayName: 'Trend Value 2',
                }
            ],
            objects: {
                general: {
                    displayName: data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        ActualFillColor: {
                            displayName: 'Main Color',
                            type: { fill: { solid: { color: true } } }
                        },
                        ComparisonFillColor: {
                            displayName: 'Comparison Color',
                            type: { fill: { solid: { color: true } } }
                        },
                    },
                },
                  labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointLabel'),
                    properties: {
                        color: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                            type: { fill: { solid: { color: true } } }
                        },
                        labelDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        labelPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            type: { numeric: true }
                        },
                    },
                }
            },
            dataViewMappings: [{
                conditions: [
                    { 'Y': { max: 1 }, 'TargetValue': { max: 1 }, 'MinValue': { max: 1 }, 'MaxValue': { max: 1 }, 'QualitativeState1Value': { max: 1 }, 'QualitativeState2Value': { max: 1 }},//Maximum no. of values we can provide
                ],
                categorical: {
                    values: {
                        select: [
                            { bind: { to: 'Y' } },                         
                            { bind: { to: 'TargetValue' } },
                            { bind: { to: 'MinValue' } },
                            { bind: { to: 'MaxValue' } },
                            { bind: { to: 'QualitativeState1Value' } },
                            { bind: { to: 'QualitativeState2Value' } }//Binding with the categorical object
                        
                        ]
                    },
                },
            }],
            suppressDefaultTitle: true,
        };

        //One time setup
        //First time it will be called and made the structure of your visual
        public init(options: VisualInitOptions): void { 
            this.heading=d3.select(options.element.get(0))
            .append('div')
            .classed('mainTitle',true);
            
            this.svg = d3.select(options.element.get(0))
                .append('div')
                .classed('data_tab',true);
			 	
			this.svgLinear = this.svg
                .append('div').classed('data_tab',true);
				           
            this.actual=d3.select(options.element.get(0))
                .append('text')
                .classed('data_total', true)
                .text('');
                                                    
            this.percentage = d3.select(options.element.get(0))
                .append('text')
                .classed('data_percentage', true)
				.text('');	
							
			this.svg = d3.select(options.element.get(0))
                .append('div')
                .classed('imagetab',true); 
				
			this.svgLinear = this.svg
                .append('div');
				this.svgLinearNext = this.svg
                .append('div');
          
            this.trendValue1 = this.svgLinear
                .append('div')
                .classed('trendvalue1', true) ;                                                                                                                                                                   
            this.trendValue2 = this.svgLinearNext
                .append('div')
                .classed('trendvalue2', true);
              
                                                                                                                                     									
            this.svg = d3.select(options.element.get(0))
                .append('svg')
                .classed('linearSVG', true);
            
         
            this.svgLinear = this.svg
                .append('g');

            var titleLabels = this.svgLinear
                .append('g')
                .style('text-anchor', 'end');

            this.svgTitle = titleLabels
                .append('text')
                .classed('title', true);

            this.svgSubtitle = titleLabels
                .append('text')
                .attr('dy', '1em')
                .classed('subtitle', true);
                                           
            this.min=  d3.select(options.element.get(0))
                .append('div')
                .classed('scale', true)
                .text(0);    
           this.targetText=d3.select(options.element.get(0))
                .append('div')
                .classed('targetText',true); 
        }
        
        //Convert the dataview into its view model
        //All the variable will be populated with the value we have passed
        public static converter(dataView: DataView): LinearGaugeBySQLBIData {

            var data: LinearGaugeBySQLBIData = LinearGauge.getDefaultData();
            
            if (dataView.categorical) {

                if (dataView.metadata) {
                    var objects = dataView.metadata.objects;
                if (objects) {
                        data.colorActual = DataViewObjects.getFillColor(objects, linearGaugeProps.general.ActualFillColor, data.colorActual);
                        data.colorComparison = DataViewObjects.getFillColor(objects, linearGaugeProps.general.ComparisonFillColor, data.colorComparison);              
                    }
                    var toolTipItems = [];

                    var actualFlag=false, maxFlag=false, values = dataView.categorical.values;

                    if (values && dataView.metadata.columns) {
                        for (var i = 0; i < values.length; i++) {

                            var col = dataView.metadata.columns[i];
                            var value = values[i].values[0] || 0;
                            if (col && col.roles) {

                                var pushToTooltips = false;

                                if (col.roles['Y']) { // we are marching the role and populating value
                              if(col.format==='\\$#,0;(\\$#,0);\\$#,0')//here we are checking the format Ex:it is a currency format
                              {
                                  data.actualFormat='$';
                              }                                                                                  
                                    data.actual=value; 
									actualFlag=true; 
                                    pushToTooltips = true;// pass the value as true to make it as a tooltip
                                } else if (col.roles['MinValue']) {
                                   if(col.format==='\\$#,0;(\\$#,0);\\$#,0')
                              {
                                  data.minFormat='$';
                              }
                                    data.min = value;									
                                } else if (col.roles['MaxValue']) {
                                     if(col.format==='\\$#,0;(\\$#,0);\\$#,0')
                              {
                                  data.maxFormat='$';
                              }
							  maxFlag=true;
                                    data.max = value;   									                                                                                                                                                                   
                                 }else if (col.roles['TargetValue']) {
                                 if(col.format==='\\$#,0;(\\$#,0);\\$#,0')
                              {
                                  data.targetFormat='$';
                              }    
                                    data.target = value;
                                    pushToTooltips = true;
                                }
                                else if (col.roles['QualitativeState1Value'])
                                    {
                                       
                                         data.trendValue1 = value;
                                         if(col.format=='0%;-0%;0%' || col.format=='0 %;-0 %;0 %')
                                  data.trend1Format='%';
                                 
                                    }
                                    else if (col.roles['QualitativeState2Value'])
                                    {
                                         data.trendValue2 = value;
                                         if(col.format=='0%;-0%;0%' || col.format=='0 %;-0 %;0 %')
                                           data.trend2Format='%';
                              
                                    }
								if (pushToTooltips)
                                
                                    toolTipItems.push({ value: value, metadata: values[i] });
                            }
                        }
						if(!maxFlag && actualFlag && data.actual>0)
						{
							data.max=data.actual*2;
						}
                        if(data.max==0)
                        {
                            data.max=1;
                        }
                       
                    }

                    if (toolTipItems.length > 0) {
                        data.toolTipInfo = TooltipBuilder.createTooltipInfo({
                            objectName: 'general',
                            propertyName: 'formatString',
                        }, null, null, null, null, toolTipItems);
                    }
                }
            }

            return data;//Data object we are returning here to the update function
        }

       //Drawing the visual
        public update(options: VisualUpdateOptions) {    
         
             
                 this.cardFormatSetting = this.getDefaultFormatSettings();
            var labelSettings=null; 
            var dataView = options.dataViews[0];
            
            var value: any;
            if (dataView) {
                this.getMetaDataColumn(dataView);
                if (dataView.single) {
                    value = dataView.single.value;
                }

                var dataViewMetadata = dataView.metadata;
                if (dataViewMetadata) {
                    var objects: DataViewObjects = dataViewMetadata.objects;
                    if (objects) {
                      labelSettings = this.cardFormatSetting.labelSettings;

                        labelSettings.labelColor = DataViewObjects.getFillColor(objects, cardProps.labels.color, labelSettings.labelColor);
                        labelSettings.precision = DataViewObjects.getValue(objects, cardProps.labels.labelPrecision, labelSettings.precision);

                        // The precision can't go below 0
                        if (labelSettings.precision != null) {
                            labelSettings.precision = (labelSettings.precision >= 0) ? labelSettings.precision : 0;
                        }

                        labelSettings.displayUnits = DataViewObjects.getValue(objects, cardProps.labels.labelDisplayUnits, labelSettings.displayUnits);
                       
                    }
                }
            }
                                                                                                    
            if (!options.dataViews || !options.dataViews[0]) return;
            var dataView = this.dataView = options.dataViews[0];
            var viewport = options.viewport;//We will get width and height from viewport object.

            this.data = LinearGauge.converter(dataView);//calling Converter function
           
            
             var maxValue = Math.max(Math.abs(this.data.target),Math.abs(this.data.value), Math.abs(this.data.comparison), Math.abs(this.data.max));
            if (this.data.states.length === 0)
                this.data.states = [Math.ceil(maxValue) / 3, (Math.ceil(maxValue) / 3) * 2, Math.ceil(maxValue)];
            
           var sortedRanges = this.data.states.slice().sort(d3.descending);
          //sortedRanges[0]=sortedRanges[0]-10;
           // sortedRanges.unshift(maxValue+10);

            var titleWidth = TextMeasurementService.measureSvgTextWidth({ fontFamily: 'tahoma', fontSize: '16px', text: this.data.titleLabel });
            var showSubtitle = (this.data.subTitleLabel.length > 0);
            var subtitleWidth = TextMeasurementService.measureSvgTextWidth({ fontFamily: 'tahoma', fontSize: '12px', text: this.data.subTitleLabel });
            var labelWidth = (this.data.showLabel ? Math.max(titleWidth, subtitleWidth) : 0);
            var precisionValue=0,displayunitValue=0,color='black';
            var height = viewport.height;
            var width = viewport.width;
            var modHeight=height/12;
            this.svg
                .attr({
                    'height': viewport.height/11,
                    'width': viewport.width
                });

            if (this.data.showLabel) {
                this.svgTitle
                    .style('display', 'none')
                    .attr('transform', 'translate(-10,' + ((20) + (showSubtitle ? 0 : 10)) + ')')
                    .text(this.data.titleLabel);
                this.svgLinear.attr('transform', 'translate(' + (10) + ',5)');

                if (showSubtitle) {
                    this.svgSubtitle
                        .style('display', 'none')
                        .attr('transform', 'translate(-10,' + ((height / 23) + 1) + ')')
                        .text(this.data.subTitleLabel);
                } else {
                    this.svgSubtitle.style('display', 'none');
                }

            } else {
                this.svgTitle.style('display', 'none');
                this.svgSubtitle.style('display', 'none');
                this.svgLinear.attr('transform', 'translate(10,5)');
            }
            if(labelSettings!=undefined){
              precisionValue= (labelSettings.precision!=undefined?labelSettings.precision:0);  
             displayunitValue =(labelSettings.displayUnits?labelSettings.displayUnits:0);
              color=labelSettings.labelColor;
            }
            			            
            var percentageVal,actualVal,minVal,maxVal,targetVal;
           
			if(this.data.target===0)
			{
				percentageVal=0;
			}
			else{
				percentageVal=((this.data.actual*100)/this.data.target).toFixed(2);
			}
	            //we are calculating value dynamically and using in style proerties to make component more responsive                                         
        function exponentToNumber(input){
    var data= String(input).split(/[eE]/);
    if(data.length== 1) return data[0]; 

    var  z= '', sign= this<0? '-':'',
    str= data[0].replace('.', ''),
    mag= Number(data[1])+ 1;

    if(mag<0){
        z= sign + '0.';
        while(mag++) z += '0';
        return z + str.replace(/^\-/,'');
    }
    mag -= str.length;  
    while(mag--) z += '0';
    return str + z;
}
            function  newFormat(c,b){

var length= (typeof(c.toString().split(".")[1])!='undefined')?c.toString().split(".")[1].length:0
var a=(typeof(c.toString().split(".")[1])!='undefined')?c.toString().split(".")[1]:0
var beforeDecimal=c.toString().split(".")[0];
var f=beforeDecimal;
if(b!=0)
f=f+'.';
if(length!=0 || b!=0)
{
for(var i=0;i<b;i++)
{
f=f+(typeof(a[i])!="undefined" ? a[i]:0);
}
}
return f;
}
       
        
        
          switch(displayunitValue){
              case 0:
              {
                 actualVal=newFormat(this.data.actual,precisionValue);
                  minVal=newFormat(this.data.min,precisionValue);                  
                  targetVal=newFormat(this.data.target,precisionValue);   
                  for(var a=0;a<this.data.toolTipInfo.length;a++)
                  {              
                 this.data.toolTipInfo[a].value=newFormat(this.data.toolTipInfo[a].value,precisionValue);
                  }
                  break;
              }
               case 1:
              {
                 actualVal=numberWithCommas(newFormat(this.data.actual,precisionValue));
                  minVal=numberWithCommas(newFormat(this.data.min,precisionValue));
                  targetVal=numberWithCommas(newFormat(this.data.target,precisionValue));
                   for(var a=0;a<this.data.toolTipInfo.length;a++)
                   {
                   this.data.toolTipInfo[a].value=numberWithCommas(newFormat(this.data.toolTipInfo[a].value,precisionValue));
                   }
                  break;
              }
                case 1000:
              {
                  
                  actualVal=newFormat((this.data.actual/1000),precisionValue)+'K';               
                  minVal=newFormat((this.data.min/1000),precisionValue)+'K';
                  targetVal=newFormat((this.data.target/1000),precisionValue)+'K';
                  for(var a=0;a<this.data.toolTipInfo.length;a++)
                  {
                   this.data.toolTipInfo[a].value=(newFormat((Number(this.data.toolTipInfo[a].value)/1000),precisionValue)+'K').toString();
                  }
                  break;
              }
               case 1000000:
              {
                  actualVal=newFormat((this.data.actual/1000000),precisionValue)+'M';  
                    minVal=newFormat((this.data.min/1000000),precisionValue)+'M';
                      targetVal=newFormat((this.data.target/1000000),precisionValue)+'M';
                      for(var a=0;a<this.data.toolTipInfo.length;a++)
                  {
                   this.data.toolTipInfo[a].value=(newFormat((Number(this.data.toolTipInfo[a].value)/1000000),precisionValue)+'M').toString();
                  }
                 
                  break;
              }
                case 1000000000:
              {
                   actualVal=newFormat((exponentToNumber(this.data.actual/1000000000)),precisionValue)+'bn';  
                    minVal=newFormat((exponentToNumber(this.data.min/1000000000)),precisionValue)+'bn';
                      targetVal=newFormat((exponentToNumber(this.data.target/1000000000)),precisionValue)+'bn';
                     for(var a=0;a<this.data.toolTipInfo.length;a++)
                  {
                   this.data.toolTipInfo[a].value=(newFormat((Number(this.data.toolTipInfo[a].value)/1000000000),precisionValue)+'bn').toString();
                  }   
                  break;
                 
              }
                case 1000000000000:
              {
                  actualVal=newFormat((exponentToNumber(this.data.actual/1000000000000)),precisionValue)+'T';  
                    minVal=newFormat((exponentToNumber(this.data.min/1000000000000)),precisionValue)+'T';
                      targetVal=newFormat((exponentToNumber(this.data.target/1000000000000)),precisionValue)+'T';
                       for(var a=0;a<this.data.toolTipInfo.length;a++)
                  {
                   this.data.toolTipInfo[a].value=(newFormat((Number(this.data.toolTipInfo[a].value)/1000000000000),precisionValue)+'T').toString();
                  }   
                  break;
                 
              }

          }
              
              
                              
            this.actual.text(this.data.actualFormat+actualVal);//Using values which are stored in data object
          
            
         
            this.percentage.text((percentageVal)+'%');
			this.min.text(this.data.minFormat+minVal);	           
                       
           // var targetPercentage=(((this.data.target-this.data.min)*100)/this.data.max)+'%';
            //var targetPercentageTest=((((this.data.target-this.data.min)*100)/this.data.max)-1)+'%';
            var upArrow='&#8599;',arrowClassTV1,arrowClassTV2; 
             var customwidth=(window.getComputedStyle($(this.svg[0][0])[0]).width).slice(0,-2);
            var wifth=Number(customwidth)-10;
            
            var percen=(((this.data.target-this.data.min)*100)/this.data.max);
            percen=(isNaN(percen))?0:percen;
           var passingValue= (((wifth*percen)/100)<=0)?0:((wifth*percen)/100);
             
              var passingTextvalue=(wifth*(percen-2))/100;  
            //Scale on X-axis
            var actualFont=((width+height)/22);
			var percentageFont=actualFont/2.5;
			var topMargin=(height/7)+'px';
           this.actual.style('font-size',actualFont+'px');
           this.actual.style('color',color);
		   this.actual.style('margin-right',percentageFont+'px');
		   this.percentage.style('font-size',percentageFont+'px');            
		   this.percentage.style('padding-top',(percentageFont+5)+'px');
           this.percentage.style('color',color);                                              
		   var trendValue1Text,trendValue2Text;
           var indexQualStatVal1,indexQualStatVal2,flagQualStatVal1=false,flagQualStatVal2=false,lengthColumn=options.dataViews[0].metadata.columns.length;
          //Populating Trend Value 1 and Trend Value 2 data  
          for(var ite=0;ite<lengthColumn;ite++)
          {
              if(dataView.metadata.columns[ite].roles['QualitativeState1Value']===true)
              {
                  flagQualStatVal1=true;
                  indexQualStatVal1=ite;
              } 
               if(dataView.metadata.columns[ite].roles['QualitativeState2Value']===true)
              {
                  flagQualStatVal2=true;
                  indexQualStatVal2=ite;
              } 
               
          }
		   if(flagQualStatVal1)
		   {
               trendValue1Text=dataView.metadata.columns[indexQualStatVal1].displayName; 		
		   }
		   else
		   {
			 trendValue1Text='';    
		   }
		    if(flagQualStatVal2)
		   {
               trendValue2Text=dataView.metadata.columns[indexQualStatVal2].displayName;   
			
		   }
		   else
		   {
			 trendValue2Text='';  
		   }
		   //Adding css dynamically to make the component responsive, all values are calculated from Viewport value
		    this.heading.style('margin-top',topMargin);		   
		    this.trendValue1.style('font-size',percentageFont+'px');
			 this.trendValue2.style('font-size',percentageFont+'px');			
            var scale = d3.scale.linear()
                .domain([0, Math.max(sortedRanges[0], this.data.target, this.data.value)])
                .range([0, width]);  
				
				                   
		 if(flagQualStatVal1)
         {			
             this.trendValue1.style('display','inline');				    
           this.trendValue1.select('span.trendvalue1arrow').remove();
			this.trendValue1.select('span').remove();
            this.trendValue1.append('span')
                .classed('trendvalue1arrow', true)             						
				.html(upArrow);
			this.trendValue1.append('span').text(Math.abs(this.data.trendValue1)+this.data.trend1Format+' '+trendValue1Text);	
              
               
			    if(this.data.trendValue1<0){
            //$('.trendvalue1arrow').css('Transform','rotate(90deg)');
             
            if((this.trendValue1[0][0].querySelectorAll(".trendvalue1arrow")).length!=0) 
            {
            arrowClassTV1= this.trendValue1[0][0].querySelectorAll(".trendvalue1arrow");
           arrowClassTV1[0].style.transform = "rotate(90deg)";
           arrowClassTV1[0].style.display="inline-block"
            }
           }       
         }	
         else
         {           
             this.trendValue1.style('display','none');
         }	
	 if(flagQualStatVal2)
     {
		this.trendValue2.style('display','inline');	
		 
		 
       
			 this.trendValue2.select('span.trendvalue2arrow').remove();
			  this.trendValue2.select('span').remove();
            this.trendValue2.append('span')
                .classed('trendvalue2arrow', true)              
				.html(upArrow);								
		this.trendValue2.append('span').text(Math.abs(this.data.trendValue2)+this.data.trend2Format+' '+trendValue2Text);   
		if(this.data.trendValue2<0){  
              if((this.trendValue2[0][0].querySelectorAll(".trendvalue1arrow")).length!=0) 
             {
               arrowClassTV2= this.trendValue2[0][0].querySelectorAll(".trendvalue2arrow");
           arrowClassTV2[0].style.transform = "rotate(90deg)";
             arrowClassTV2[0].style.display="inline-block"     
             }    
		// $('.trendvalue2arrow').css('Transform','rotate(90deg)');
           }        
     }	
     else
     {
        this.trendValue2.style('display','none');	
     }			
     		  if((this.trendValue1[0][0].querySelectorAll(".trendvalue1arrow")).length!=0) 
             {		
                arrowClassTV1= this.trendValue1[0][0].querySelectorAll(".trendvalue1arrow");  									
 			//arrowClassTV1[0].style('font-size',percentageFont+4+'px');
             arrowClassTV1[0].style.fontSize=percentageFont+4+'px';
             }
			 if((this.trendValue2[0][0].querySelectorAll(".trendvalue1arrow")).length!=0) 
             {
                 arrowClassTV2= this.trendValue2[0][0].querySelectorAll(".trendvalue2arrow"); 
            arrowClassTV2[0].style.fontsize=percentageFont+4+'px';
             }
            //Ranges
            var range = this.svgLinear.selectAll('rect.range')
                .data(sortedRanges);

            range.enter()
                .append('rect')                
                .attr('class', function (d, i) { return 'range s' + i; });

            range
                .attr('x', 0)
                .attr('width', function (d) { return Math.abs(scale(d) - scale(0)); })
                .attr('height', modHeight)
                .style('fill',this.data.colorComparison);
				
			//this.targetText.append('span').text("300").style("float","right").style("margin-right","20px"); 


            //Comparison measure
             this.svgLinear.selectAll('rect.measure').remove();
            if (this.data.comparison > 0) {
                var comparison = this.svgLinear
                    .append('rect')
                    .classed('measure', true)
                    .style('fill', this.data.colorComparison);

                comparison
                    .attr('width', scale(this.data.comparison))
                    .attr('height', (modHeight / 3))
                    .attr('x', 0)
                    .attr('y', (modHeight / 3));
            }
            //var actual=this.data.actual-this.data.min;
            var percent=(((this.data.actual-this.data.min)*100)/this.data.max);
            percent=(isNaN(percent))?0:percent;
            var actual= (((width*percent)/100)<=0)?0:((width*percent)/100);
            actual=(isNaN(actual))?0:actual;
            //Main measure
            var measure = this.svgLinear
                .append('rect')
                .classed('measure', true)
                .style('fill', this.data.colorActual);

            measure
                .attr('width', actual)
                .attr('height', modHeight)
                .attr('x', 0)
                .attr('y', 0);

            //Target markers
            this.svgLinear.selectAll('line.marker').remove();
            var marker = this.svgLinear
                .append('line')
                .classed('marker', true)
                .style('stroke','black');  
                 var startingPoint=0;
                  var minvalueWidth=0,tiltend;
               
                // if(globalminValue!=minVal || globalTargetValue!=targetVal)
                // {
                var customMin=(window.getComputedStyle($(this.min[0][0])[0]).width).slice(0,-2);
                
                   startingPoint=Number(customMin)+10; 
                   globalminLength=startingPoint;
                  var customsvgWidth=(window.getComputedStyle($(this.svg[0][0])[0]).width).slice(0,-2);
                   var fullsvgWidth=Number(customsvgWidth);
                     minvalueWidth=(fullsvgWidth*(((this.data.target-this.data.min)*100)/this.data.max))/100;
                  globalTargetWidth=minvalueWidth; 
                // }           
           
          
            // if(globalTargetValue!=targetVal)
            //     {
            //        var fullsvgWidth=$('.linearSVG')[0].getBoundingClientRect().width; 
            //         minvalueWidth=(fullsvgWidth*((this.data.target*100)/this.data.max))/100;
            //      globalTargetWidth=minvalueWidth;
            //     }  
			 var targetValueText= this.data.targetFormat+targetVal
			 
			  
			  var targetTextwidth=9*targetValueText.length+10; 
			   
           var flag=false;
            if(globalTargetWidth<globalminLength ||passingValue<(targetTextwidth+startingPoint))
            {
            tiltend= globalminLength+10;
			flag=true; 
            }  
            else
            {
            tiltend=passingValue;
			   flag=false;   
            }                      
            marker
            .attr(
                   {x1:passingValue,
                     y1:0,
                    x2:passingValue,
                    y2:modHeight});
    this.svgLinear.selectAll('line.markerTilt').remove();       
     var tiltmarker = this.svgLinear
                .append('line')
                .classed('markerTilt', true)
                .style('stroke','black');
            tiltmarker
            .attr(
                    {x1:passingValue,
                     y1:modHeight,
                     x2:(tiltend),
                     y2:(modHeight+10)});

        if(globalTargetWidth>globalminLength)
        {
            this.svgLinear.selectAll('line.markerTilt').remove();     
        }
              //Target Text   
              var customwifth=(window.getComputedStyle($(this.svg[0][0])[0]).width).slice(0,-2);
	  var wifth= Number(customwifth)-10;
            var percen=(((this.data.target-this.data.min)*100)/this.data.max);
            percen=(isNaN(percen))?0:percen;
            var passingValue= (((wifth*percen)/100)<=0)?0:((wifth*percen)/100);
            
			var diff=wifth-passingValue;
			
			
if(flag==false)
{			
			 this.targetText.selectAll('span.markerTarget').remove(); 	
			 this.svgLinear.selectAll('text.markerTarget').remove();	 			  			     
            var markerText = this.targetText
                .append('span')
                .classed('markerTarget', true)
                //.style('fill',color) 
                //.style('text-anchor','start')             
                .text(this.data.targetFormat+targetVal)
				.style("float","right")
				.style("margin-right",diff+'px');
				this.targetText.style("Display","inline");
}
else{				
				
			 this.targetText.selectAll('span.markerTarget').remove(); 
			 this.svgLinear.selectAll('text.markerTarget').remove();
			 var markerText = this.svgLinear
                .append('text')
                .classed('markerTarget', true)
                .style('fill',color) 
                .style('text-anchor','start')             
                .text(this.data.targetFormat+targetVal)												
               
            
            markerText
                .attr('width',1)
                .attr('height', modHeight)
                .attr('x', tiltend)
                .attr('y',(modHeight+20))
                .attr('overflow','visible !important'); 
				this.targetText.style("Display","None");
 }		
                         
                function numberWithCommas(x) {
                 return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                }
                if(this.data.target<=this.data.min || passingValue<0)
                {
                    this.svgLinear.selectAll('text.markerTarget').remove();
                     this.svgLinear.selectAll('line.marker').remove(); 
                      this.svgLinear.selectAll('line.markerTilt').remove();        
                }     
                if(this.data.actual>this.data.max)
                {
                this.svgLinear.selectAll('.measure').style('display','none');
                   this.svgLinear.selectAll('.marker').style('display','none');
                   this.targetText.style('display','none');
                   this.svgLinear.selectAll('line.marker').remove(); 
                      this.svgLinear.selectAll('line.markerTilt').remove(); 
                      this.svgLinear.selectAll('text.markerTarget').remove();
                             
                }
                else{
                        this.svgLinear.selectAll('.measure').style('display','block');
                   this.svgLinear.selectAll('.marker').style('display','block');
                   this.targetText.style('display','block');
                }
                                                     
            TooltipManager.addTooltip(this.svgLinear, (tooltipEvent: TooltipEvent) => this.data.toolTipInfo);//Adding visual tips
        globalminValue=minVal;
        globalTargetValue=targetVal;
        } 

        //Make visual properties available in the property pane in Power BI
        //values which we can customized from property pane in Power BI 
       
        
        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {
          
            var enumeration = new ObjectEnumerationBuilder();
            if (!this.data)
                this.data = LinearGauge.getDefaultData();
                  if (!this.cardFormatSetting)
                this.cardFormatSetting = this.getDefaultFormatSettings();

            var formatSettings = this.cardFormatSetting;

            switch (options.objectName) {
                case 'general':
                    enumeration.pushInstance({
                        objectName: 'general',
                        displayName: 'General',
                        selector: null,
                        properties: {
                            ActualFillColor: this.data.colorActual,
                            ComparisonFillColor: this.data.colorComparison
                        }
                    });
                    break;

                case 'labels':
                    var labelSettingOptions: VisualDataLabelsSettingsOptions = {
                        enumeration: enumeration,
                        dataLabelsSettings: formatSettings.labelSettings,
                        show: true,
                        displayUnits: true,
                        precision: true,
                    };
                    dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                    break;

            }

            return enumeration.complete();
        }

        //Free up resources variable which we have declared initially for just better performance        
       
    }
}